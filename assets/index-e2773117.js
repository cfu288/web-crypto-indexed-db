(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))s(e);new MutationObserver(e=>{for(const r of e)if(r.type==="childList")for(const i of r.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function n(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerpolicy&&(r.referrerPolicy=e.referrerpolicy),e.crossorigin==="use-credentials"?r.credentials="include":e.crossorigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(e){if(e.ep)return;e.ep=!0;const r=n(e);fetch(e.href,r)}})();const u={DATABASE_NAME:"KeyDb",OBJECT_STORE_NAME:"KeyObjectStore",VERSION:1,KEY_ID:1},d={name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-384",extractable:!1,keyUsages:["sign","verify"]};function g(){return window.crypto.subtle.generateKey({name:d.name,modulusLength:d.modulusLength,publicExponent:d.publicExponent,hash:d.hash},d.extractable,d.keyUsages)}function x(o,t){return window.crypto.subtle.sign({name:d.name,hash:d.hash},t,o)}function B(o,t,n){return window.crypto.subtle.verify({name:d.name,hash:d.hash},t,n,o)}function p(){const t=window.indexedDB.open(u.DATABASE_NAME,u.VERSION);return t.onupgradeneeded=function(){t.result.createObjectStore(u.OBJECT_STORE_NAME,{keyPath:"id"})},t}async function w(){return new Promise((o,t)=>{const n=p();n.onsuccess=function(){const s=n.result,i=s.transaction(u.OBJECT_STORE_NAME,"readwrite").objectStore(u.OBJECT_STORE_NAME).get(u.KEY_ID);i.onsuccess=async function(){try{const c=await h(i,s),a=await window.crypto.subtle.exportKey("jwk",c.publicKey);o(a)}catch(c){t(c)}}}})}async function O(o){return new Promise((t,n)=>{const s=p();s.onsuccess=function(){const e=s.result,c=e.transaction(u.OBJECT_STORE_NAME,"readwrite").objectStore(u.OBJECT_STORE_NAME).get(u.KEY_ID);c.onsuccess=async function(){try{const a=await h(c,e),l=await x(o,a.privateKey);t(l)}catch(a){n(a)}},c.onerror=async function(){n(c.error)}}})}async function h(o,t){var s;let n=(s=o.result)==null?void 0:s.keys;if(!n){if(n=await g(),g()===void 0)throw new Error("Could not create keys - Your browser does not support WebCrypto or you are running without SSL enabled.");t.transaction(u.OBJECT_STORE_NAME,"readwrite").objectStore(u.OBJECT_STORE_NAME).put({id:1,keys:n})}return n}function _(o,t){return new Promise((n,s)=>{const e=p();e.onsuccess=function(){const a=e.result.transaction(u.OBJECT_STORE_NAME,"readwrite").objectStore(u.OBJECT_STORE_NAME).get(u.KEY_ID);a.onsuccess=async function(){const l=a.result.keys.publicKey,y=await B(o,l,t);n(y)},a.onerror=async function(){s(a.error)}}})}function b(o){return S(f(o))}function S(o){const t=new Uint8Array(o);let n="";return t.forEach(s=>{n+=String.fromCharCode(s)}),btoa(n).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function T(o){let t=o.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");const n=t.length%4;if(n){if(n===1)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");t+=new Array(5-n).join("=")}const s=atob(t),e=s.length,r=new Uint8Array(e);for(let i=0;i<e;i++)r[i]=s.charCodeAt(i);return r.buffer}function f(o){const t=btoa(o);return T(t)}async function E(o){const t={alg:"RS384",typ:"JWT",kid:u.KEY_ID},n=Math.floor(Date.now()/1e3),e={iat:n,nbf:n,exp:n+300,...o},r=JSON.stringify(t),i=JSON.stringify(e),c=b(r),a=b(i),l=`${c}.${a}`,y=f(l),m=await O(y),A=S(m);return`${l}.${A}`}async function k(o){const[t,n,s]=o.split("."),e=f(`${t}.${n}`),r=T(s);return await _(e,r)}async function v(o,t,n,s){let e=!1;const r=()=>{const l=e?"Sign JWT":"Reset";o.innerHTML=l,e=!e},i=l=>{s.innerHTML=l,s.style.display=l?"block":"none"},c=l=>{t.innerHTML=`${l}`},a=()=>JSON.parse(n.value);o.addEventListener("click",async()=>{r(),i(e?`${await E(a())}`:""),c(e?"Signed JWT using body from input field and private key from IndexedDB. You can validate this JWT at <a href='https://jwt.io/' target='_blank'>jwt.io</a> using the public key from the previous section.":"")}),r(),r(),i(""),c("")}async function J(o,t,n,s){let e=!0;const r=()=>{e=!e;const a=e?"Hide public key":"Generate key pair and show public";o.innerHTML=a},i=a=>{n.innerHTML=a,n.style.display=a?"block":"none"},c=a=>{t.innerHTML=`${a}`};o.addEventListener("click",async()=>{r(),i(e?`${JSON.stringify(await w(),null,2)}`:""),c(e?"This public key is persisted in IndexedDB - try refreshing to see that you'll always get the same result. The private key is not shown as it is not exposed. If you want to restart this demo with a new key pair, clear your IndexedDB storage.":""),s()}),r(),i("")}document.querySelector("#app").innerHTML=`
<div id="step1">
  <article>
    <h2>1) Generate public + private key pair</h2>
    <button id="pkButton" type="button"></button>
    <p id="publicKeySubtitle"></p>
    <pre id="pkDisplay"></pre>
  </article>
</div>
<div id="step2"></div>
<div id="step3"></div>
`;const K=`
<article>
<h2>2) Sign JWT</h2>
<p>
  <label>JWT Body</label>
  <input id="jwtInput" type="text" value='{"hello": "world"}' />
</p>
<button id="jwtButton" type="button"></button>
<p id="jwtSubtitle"></p>
<pre id="jwtDisplay"></pre>
</article>
`;J(document.querySelector("#pkButton"),document.querySelector("#publicKeySubtitle"),document.querySelector("#pkDisplay"),()=>{document.querySelector("#step2").innerHTML=K,v(document.querySelector("#jwtButton"),document.querySelector("#jwtSubtitle"),document.querySelector("#jwtInput"),document.querySelector("#jwtDisplay"))});(async()=>{const o=await w();console.group("Public Key"),console.log(o),console.groupEnd();const t=await E({hello:"world"});console.group("JWT created and signed using Private Key"),console.log(t),console.groupEnd();const n=await k(t);console.group("Validate JWT using Public Key"),console.log(n?"JWT is valid":"JWT is invalid"),console.groupEnd()})();
