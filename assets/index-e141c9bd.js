(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))s(e);new MutationObserver(e=>{for(const o of e)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function t(e){const o={};return e.integrity&&(o.integrity=e.integrity),e.referrerpolicy&&(o.referrerPolicy=e.referrerpolicy),e.crossorigin==="use-credentials"?o.credentials="include":e.crossorigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(e){if(e.ep)return;e.ep=!0;const o=t(e);fetch(e.href,o)}})();const d={DATABASE_NAME:"KeyDb",OBJECT_STORE_NAME:"KeyObjectStore",VERSION:1,KEY_ID:1},y={name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-384",extractable:!1,keyUsages:["sign","verify"]};function T(){return window.crypto.subtle.generateKey({name:y.name,modulusLength:y.modulusLength,publicExponent:y.publicExponent,hash:y.hash},y.extractable,y.keyUsages)}function J(r,n){return window.crypto.subtle.sign({name:y.name,hash:y.hash},n,r)}function O(r,n,t){return window.crypto.subtle.verify({name:y.name,hash:y.hash},n,t,r)}function h(){const n=window.indexedDB.open(d.DATABASE_NAME,d.VERSION);return n.onupgradeneeded=function(){n.result.createObjectStore(d.OBJECT_STORE_NAME,{keyPath:"id"})},n}async function _(){return new Promise((r,n)=>{const t=h();t.onsuccess=function(){const s=t.result,i=s.transaction(d.OBJECT_STORE_NAME,"readwrite").objectStore(d.OBJECT_STORE_NAME).get(d.KEY_ID);i.onsuccess=async function(){try{const a=await v(i,s),c=await window.crypto.subtle.exportKey("jwk",a.publicKey);r(c)}catch(a){n(a)}}}})}async function L(r){return new Promise((n,t)=>{const s=h();s.onsuccess=function(){const e=s.result,a=e.transaction(d.OBJECT_STORE_NAME,"readwrite").objectStore(d.OBJECT_STORE_NAME).get(d.KEY_ID);a.onsuccess=async function(){try{const c=await v(a,e),l=await J(r,c.privateKey);n(l)}catch(c){t(c)}},a.onerror=async function(){t(a.error)}}})}async function v(r,n){var s;let t=(s=r.result)==null?void 0:s.keys;if(!t){if(t=await T(),T()===void 0)throw new Error("Could not create keys - Your browser does not support WebCrypto or you are running without SSL enabled.");n.transaction(d.OBJECT_STORE_NAME,"readwrite").objectStore(d.OBJECT_STORE_NAME).put({id:1,keys:t})}return t}function j(r,n){return new Promise((t,s)=>{const e=h();e.onsuccess=function(){const c=e.result.transaction(d.OBJECT_STORE_NAME,"readwrite").objectStore(d.OBJECT_STORE_NAME).get(d.KEY_ID);c.onsuccess=async function(){const l=c.result.keys.publicKey,p=await O(r,l,n);t(p)},c.onerror=async function(){s(c.error)}}})}function E(r){return k(m(r))}function k(r){const n=new Uint8Array(r);let t="";return n.forEach(s=>{t+=String.fromCharCode(s)}),btoa(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function x(r){let n=r.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");const t=n.length%4;if(t){if(t===1)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");n+=new Array(5-t).join("=")}const s=atob(n),e=s.length,o=new Uint8Array(e);for(let i=0;i<e;i++)o[i]=s.charCodeAt(i);return o.buffer}function m(r){const n=btoa(r);return x(n)}async function M(r){const n={alg:"RS384",typ:"JWT",kid:d.KEY_ID},t=Math.floor(Date.now()/1e3),e={iat:t,nbf:t,exp:t+300,...r},o=JSON.stringify(n),i=JSON.stringify(e),a=E(o),c=E(i),l=`${a}.${c}`,p=m(l),f=await L(p),b=k(f);return`${l}.${b}`}async function C(r){const[n,t,s]=r.split("."),e=m(`${n}.${t}`),o=x(s);return await j(e,o)}const K=`
<article>
  <h2>2) Sign JWT</h2>
  <p>Now that we've generated a CryptoKey, we can sign payloads like JWT's using the private key and later validate them using the public key.</p>
  <p>Try providing a sample JWT body below to see how we generate and sign a JWT using the body dynamically in the browser.</p>
  <p>
    <label>JWT Body</label>
    <input id="jwtInput" type="text" value='{"hello": "world"}' />
  </p>
  <button id="jwtButton" type="button"></button>
  <p id="jwtSubtitle"></p>
  <div id="jwtResult">
    <pre id="jwtDisplay"></pre>
    <p>You can validate this JWT with the debugger at jwt.io using the public key from the previous section. Click the button below to pre-populate the above JWT in the JWT debugger automatically. Note that you'll need to copy over the public key manually to validate the signature in the debugger</p>
    <a id="jwtLink" target='_blank' style="text:center"><img src='https://jwt.io/img/badge.svg' alt='jwt.io'></img></a>
  </div>
</article>
`;function I(){document.querySelector("#step2").innerHTML="",document.querySelector("#step3").innerHTML=""}async function N(r,n){document.querySelector("#step2").innerHTML=K;const t=document.querySelector("#jwtButton"),s=document.querySelector("#jwtSubtitle"),e=document.querySelector("#jwtInput"),o=document.querySelector("#jwtDisplay"),i=document.querySelector("#jwtResult"),a=document.querySelector("#jwtLink");let c=!0,l="";const p=()=>{const u=c?"Sign JWT":"Reset";t.innerHTML=u,c=!c},f=u=>{o.innerHTML=u},b=async u=>{a.href=`https://jwt.io?access_token=${u}`},g=(u,S)=>{s.innerHTML=`${u}`,s.style.display=u?"block":"none",s.style.color=S||"black"},w=u=>{i.style.display=u?"block":"none"},A=async()=>{try{const u=JSON.parse(e.value);return e.disabled=!0,Promise.resolve(u)}catch(u){return e.disabled=!1,Promise.reject(u)}},B=()=>{e.value='{"hello": "world"}',e.disabled=!1},D=()=>{e.disabled=!0};t.addEventListener("click",async()=>{p();try{if(c){const u=await A();w(!0),l=`${await M(u)}`,f(l),g(""),await b(l),r(l)}else w(!1),g(""),B(),n()}catch{g("Invalid JSON provided. Please provide valid JSON for the JWT body.","red"),D(),f("");return}}),p(),w(!1),f(""),g(""),await b("")}const H=`
<article>
  <h2>1) Generate CryptoKey Key Pair</h2>
  <p>The following button will check to see if a CryptoKey key pair already exists in IndexedDB. If it does, it will just return the existing CryptoKey object. If not, it will generate a new one and store it in IndexedDB.</p>
  <button id="pkButton" type="button"></button>
  <p id="publicKeySubtitle"></p>
  <pre id="pkDisplay"></pre>
</article>
`;async function R(r,n){document.querySelector("#step1").innerHTML=H;const t=document.querySelector("#pkButton"),s=document.querySelector("#publicKeySubtitle"),e=document.querySelector("#pkDisplay");let o=!0;const i=()=>{o=!o;const l=o?"Hide public key":"Generate key pair and show public key";t.innerHTML=l},a=l=>{e.innerHTML=l,e.style.display=l?"block":"none"},c=l=>{s.innerHTML=`${l}`};t.addEventListener("click",async()=>{i(),o?(a(o?`${JSON.stringify(await _(),null,2)}`:""),c(o?"This public key is persisted in IndexedDB - try refreshing to see that you'll always get the same public key result. The private key is not shown as it is not exposed. If you want to restart this demo with a new key pair, clear your IndexedDB storage.":""),r()):(a(""),c(""),n())}),i(),a("")}const q=`
<article>
  <h2>3) Verify JWT</h2>
  <p>Clicking the button below will attempt to validate the JWT using the public key from the first step.</p>
  <button id="verifyButton" type="button"></button>
  <p id="verifyDisplay"></p>
</article>
`;function P(){document.querySelector("#step3").innerHTML=""}async function W(r){document.querySelector("#step3").innerHTML=q;const n=document.querySelector("#verifyButton"),t=document.querySelector("#verifyDisplay");let s=!1;const e=()=>{const i=s?"Validate":"Reset";n.innerHTML=i,s=!s},o=(i,a)=>{t.innerHTML=i,t.style.display=i?"block":"none",t.style.color=a||"black"};n.addEventListener("click",async()=>{e();const i=await C(r);o(s?`${i?"The JWT is valid ðŸŽ‰":"The JWT is not valid ðŸ˜Ÿ"}`:"",i?"green":"red")}),e(),e(),o("")}document.querySelector("#app").innerHTML=`
<div id="step1"></div>
<div id="step2"></div>
<div id="step3"></div>
`;R(()=>N(r=>W(r),()=>P()),()=>I());
