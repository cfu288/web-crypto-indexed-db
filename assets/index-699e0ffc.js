(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const t of document.querySelectorAll('link[rel="modulepreload"]'))i(t);new MutationObserver(t=>{for(const r of t)if(r.type==="childList")for(const s of r.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&i(s)}).observe(document,{childList:!0,subtree:!0});function n(t){const r={};return t.integrity&&(r.integrity=t.integrity),t.referrerpolicy&&(r.referrerPolicy=t.referrerpolicy),t.crossorigin==="use-credentials"?r.credentials="include":t.crossorigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function i(t){if(t.ep)return;t.ep=!0;const r=n(t);fetch(t.href,r)}})();const l={DATABASE_NAME:"KeyDb",OBJECT_STORE_NAME:"KeyObjectStore",VERSION:1,KEY_ID:1},y={name:"RSASSA-PKCS1-v1_5",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-384",extractable:!1,keyUsages:["sign","verify"]};function w(){return window.crypto.subtle.generateKey({name:y.name,modulusLength:y.modulusLength,publicExponent:y.publicExponent,hash:y.hash},y.extractable,y.keyUsages)}function x(o,e){return window.crypto.subtle.sign({name:y.name,hash:y.hash},e,o)}function B(o,e,n){return window.crypto.subtle.verify({name:y.name,hash:y.hash},e,n,o)}function g(){const e=window.indexedDB.open(l.DATABASE_NAME,l.VERSION);return e.onupgradeneeded=function(){e.result.createObjectStore(l.OBJECT_STORE_NAME,{keyPath:"id"})},e}async function T(){return new Promise((o,e)=>{const n=g();n.onsuccess=function(){const i=n.result,s=i.transaction(l.OBJECT_STORE_NAME,"readwrite").objectStore(l.OBJECT_STORE_NAME).get(l.KEY_ID);s.onsuccess=async function(){try{const c=await m(s,i),a=await window.crypto.subtle.exportKey("jwk",c.publicKey);o(a)}catch(c){e(c)}}}})}async function A(o){return new Promise((e,n)=>{const i=g();i.onsuccess=function(){const t=i.result,c=t.transaction(l.OBJECT_STORE_NAME,"readwrite").objectStore(l.OBJECT_STORE_NAME).get(l.KEY_ID);c.onsuccess=async function(){try{const a=await m(c,t),d=await x(o,a.privateKey);e(d)}catch(a){n(a)}},c.onerror=async function(){n(c.error)}}})}async function m(o,e){var i;let n=(i=o.result)==null?void 0:i.keys;if(!n){if(n=await w(),w()===void 0)throw new Error("Could not create keys - Your browser does not support WebCrypto or you are running without SSL enabled.");e.transaction(l.OBJECT_STORE_NAME,"readwrite").objectStore(l.OBJECT_STORE_NAME).put({id:1,keys:n})}return n}function J(o,e){return new Promise((n,i)=>{const t=g();t.onsuccess=function(){const a=t.result.transaction(l.OBJECT_STORE_NAME,"readwrite").objectStore(l.OBJECT_STORE_NAME).get(l.KEY_ID);a.onsuccess=async function(){const d=a.result.keys.publicKey,p=await B(o,d,e);n(p)},a.onerror=async function(){i(a.error)}}})}function h(o){return S(b(o))}function S(o){const e=new Uint8Array(o);let n="";return e.forEach(i=>{n+=String.fromCharCode(i)}),btoa(n).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function E(o){let e=o.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");const n=e.length%4;if(n){if(n===1)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");e+=new Array(5-n).join("=")}const i=atob(e),t=i.length,r=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=i.charCodeAt(s);return r.buffer}function b(o){const e=btoa(o);return E(e)}async function v(o){const e={alg:"RS384",typ:"JWT",kid:l.KEY_ID},n=Math.floor(Date.now()/1e3),t={iat:n,nbf:n,exp:n+300,...o},r=JSON.stringify(e),s=JSON.stringify(t),c=h(r),a=h(s),d=`${c}.${a}`,p=b(d),u=await A(p),f=S(u);return`${d}.${f}`}async function k(o){const[e,n,i]=o.split("."),t=b(`${e}.${n}`),r=E(i);return await J(t,r)}const O=`
<article>
  <h2>2) Sign JWT</h2>
  <p>Now that we've generated a public/private key pair, we can sign payloads like JWT's using the private key and later validate them using the public key.</p>
  <p>Try providing sample JWT body below to see how we generate and sign a JWT using the body dynamically in the browser.</p>
  <p>
    <label>JWT Body</label>
    <input id="jwtInput" type="text" value='{"hello": "world"}' />
  </p>
  <button id="jwtButton" type="button"></button>
  <p id="jwtSubtitle"></p>
  <pre id="jwtDisplay"></pre>
</article>
`;async function D(o){document.querySelector("#step2").innerHTML=O;const e=document.querySelector("#jwtButton"),n=document.querySelector("#jwtSubtitle"),i=document.querySelector("#jwtInput"),t=document.querySelector("#jwtDisplay");let r=!1,s="";const c=()=>{const u=r?"Sign JWT":"Reset";e.innerHTML=u,r=!r},a=u=>{t.innerHTML=u,t.style.display=u?"block":"none"},d=(u,f)=>{n.innerHTML=`${u}`,n.style.color=f||"black"},p=()=>{try{return Promise.resolve(JSON.parse(i.value))}catch(u){return Promise.reject(u)}};e.addEventListener("click",async()=>{c();try{const u=await p();s=`${await v(u)}`,a(r?s:""),d(r?"Below is the signed JWT using the above body from input field and private key previously stored from IndexedDB. You can validate this JWT at <a href='https://jwt.io/' target='_blank'>jwt.io</a> using the public key from the previous section.":""),o(s)}catch{d("Invalid JSON provided. Please provide valid JSON for the JWT body.","red"),a("");return}}),c(),c(),a(""),d("")}const _=`
<article>
  <h2>1) Generate public + private key pair</h2>
  <p>The following button will check to see if a CryptoKey key pair already exists in IndexedDB. If it does, it will just return the existing CryptoKey object. If not, it will generate a new one and store it in IndexedDB.</p>
  <button id="pkButton" type="button"></button>
  <p id="publicKeySubtitle"></p>
  <pre id="pkDisplay"></pre>
</article>
`;async function K(o){document.querySelector("#step1").innerHTML=_;const e=document.querySelector("#pkButton"),n=document.querySelector("#publicKeySubtitle"),i=document.querySelector("#pkDisplay");let t=!0;const r=()=>{t=!t;const a=t?"Hide public key":"Generate key pair and show public key";e.innerHTML=a},s=a=>{i.innerHTML=a,i.style.display=a?"block":"none"},c=a=>{n.innerHTML=`${a}`};e.addEventListener("click",async()=>{r(),s(t?`${JSON.stringify(await T(),null,2)}`:""),c(t?"This public key is persisted in IndexedDB - try refreshing to see that you'll always get the same public key result. The private key is not shown as it is not exposed. If you want to restart this demo with a new key pair, clear your IndexedDB storage.":""),o()}),r(),s("")}const M=`
<article>
  <h2>3) Verify JWT</h2>
  <p>Clicking the button below will attempt to validate the JWT using the public key from the previous section</p>
  <button id="verifyButton" type="button"></button>
  <p id="verifyDisplay"></p>
</article>
`;async function C(o){document.querySelector("#step3").innerHTML=M;const e=document.querySelector("#verifyButton"),n=document.querySelector("#verifyDisplay");let i=!1;const t=()=>{const s=i?"Validate":"Reset";e.innerHTML=s,i=!i},r=(s,c)=>{n.innerHTML=s,n.style.display=s?"block":"none",n.style.color=c||"black"};e.addEventListener("click",async()=>{t();const s=await k(o);r(i?`${s?"The JWT is valid ðŸŽ‰":"The JWT is not valid ðŸ˜Ÿ"}`:"",s?"green":"red")}),t(),t(),r("")}document.querySelector("#app").innerHTML=`
<div id="step1"></div>
<div id="step2"></div>
<div id="step3"></div>
`;K(()=>D(o=>C(o)));(async()=>{const o=await T();console.group("Public Key"),console.log(o),console.groupEnd();const e=await v({hello:"world"});console.group("JWT created and signed using Private Key"),console.log(e),console.groupEnd();const n=await k(e);console.group("Validate JWT using Public Key"),console.log(n?"JWT is valid":"JWT is invalid"),console.groupEnd()})();
